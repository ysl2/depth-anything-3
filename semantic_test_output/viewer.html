<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰ç»´è¯­ä¹‰ç‚¹äº‘æŸ¥çœ‹å™¨</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover {
            background: #45a049;
        }
        #controls button.active {
            background: #2196F3;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
        }
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            margin-right: 8px;
            border: 1px solid white;
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨åŠ è½½ç‚¹äº‘æ•°æ®...</div>

    <div id="canvas-container"></div>

    <div id="info">
        <h3>ä¸‰ç»´è¯­ä¹‰ç‚¹äº‘æŸ¥çœ‹å™¨</h3>
        <p>ç‚¹äº‘æ–‡ä»¶: semantic_pointcloud.ply</p>
        <p id="point-count">åŠ è½½ä¸­...</p>
        <div class="legend">
            <strong>æ“ä½œè¯´æ˜:</strong><br>
            ğŸ–±ï¸ å·¦é”®æ‹–æ‹½: æ—‹è½¬è§†è§’<br>
            ğŸ–±ï¸ å³é”®æ‹–æ‹½: å¹³ç§»<br>
            ğŸ”„ æ»šè½®: ç¼©æ”¾<br>
            <br>
            <strong>é¢œè‰²æ¨¡å¼:</strong>
            <div class="legend-item"><div class="legend-color" style="background: rgb(128,64,128)"></div>é“è·¯</div>
            <div class="legend-item"><div class="legend-color" style="background: rgb(70,70,70)"></div>å»ºç­‘</div>
            <div class="legend-item"><div class="legend-color" style="background: rgb(107,142,35)"></div>æ¤è¢«</div>
            <div class="legend-item"><div class="legend-color" style="background: rgb(70,130,180)"></div>å¤©ç©º</div>
            <div class="legend-item"><div class="legend-color" style="background: rgb(220,20,60)"></div>äºº</div>
        </div>
    </div>

    <div id="controls">
        <button id="btn-rgb" onclick="setColorMode('rgb')">RGBé¢œè‰²</button>
        <button id="btn-semantic" class="active" onclick="setColorMode('semantic')">è¯­ä¹‰é¢œè‰²</button>
        <button id="btn-both" onclick="setColorMode('both')">æ··åˆæ¨¡å¼</button>
        <hr style="border-color: white; margin: 10px 0;">
        <button onclick="resetCamera()">é‡ç½®è§†è§’</button>
        <button onclick="toggleAutoRotate()">è‡ªåŠ¨æ—‹è½¬: å…³</button>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/PLYLoader.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let points, geometry;
        let colorMode = 'semantic'; // 'rgb', 'semantic', 'both'
        let autoRotate = false;
        let originalColors, semanticColors;
        let frameId;

        init();
        animate();

        async function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                10000
            );
            camera.position.set(50, 30, 50);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 1000;
            controls.maxPolarAngle = Math.PI;

            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            // åŠ è½½ç‚¹äº‘
            await loadPointCloud();

            // éšè—åŠ è½½æç¤º
            document.getElementById('loading').style.display = 'none';

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
        }

        async function loadPointCloud() {
            try {
                // åŠ è½½PLYæ–‡ä»¶
                const loader = new THREE.PLYLoader();
                const response = await fetch('semantic_test_output/semantic_pointcloud.ply');
                const buffer = await response.arrayBuffer();
                geometry = loader.parse(buffer, 'binary');

                // è·å–ä½ç½®å’Œé¢œè‰²
                const positions = geometry.attributes.position.array;
                const colors = geometry.attributes.color?.array;

                console.log('ç‚¹äº‘åŠ è½½æˆåŠŸ:');
                console.log('- ç‚¹æ•°:', positions.length / 3);
                console.log('- æœ‰é¢œè‰²:', !!colors);
                console.log('- é¢œè‰²æ•°é‡:', colors ? colors.length : 0);

                document.getElementById('point-count').textContent =
                    `æ€»ç‚¹æ•°: ${(positions.length / 3).toLocaleString()}`;

                // åˆ›å»ºç‚¹æè´¨
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    sizeAttenuation: true
                });

                // åˆ›å»ºç‚¹äº‘å¯¹è±¡
                points = new THREE.Points(geometry, material);
                scene.add(points);

                // ä¿å­˜åŸå§‹é¢œè‰²å’Œè¯­ä¹‰é¢œè‰²
                if (colors) {
                    originalColors = new Float32Array(colors.length);
                    for (let i = 0; i < colors.length; i++) {
                        originalColors[i] = colors[i] / 255;
                    }

                    // æ£€æŸ¥æ˜¯å¦æœ‰è¯­ä¹‰é¢œè‰²ï¼ˆå‡è®¾ä»æŸä¸ªä½ç½®å¼€å§‹ï¼‰
                    semanticColors = new Float32Array(colors.length);
                    for (let i = 0; i < colors.length; i++) {
                        semanticColors[i] = originalColors[i]; // å…ˆä½¿ç”¨ç›¸åŒå€¼
                    }

                    // åº”ç”¨è¯­ä¹‰é¢œè‰²æ¨¡å¼
                    applySemanticColors();
                }

                // è°ƒæ•´ç›¸æœºä½ç½®ä»¥æŸ¥çœ‹ç‚¹äº‘
                geometry.computeBoundingSphere();
                const center = geometry.boundingSphere.center;
                const radius = geometry.boundingSphere.radius;

                controls.target.copy(center);
                camera.position.set(
                    center.x + radius * 2,
                    center.y + radius * 1.5,
                    center.z + radius * 2
                );
                controls.update();

                console.log('ç›¸æœºä½ç½®å·²è°ƒæ•´');

            } catch (error) {
                console.error('åŠ è½½ç‚¹äº‘å¤±è´¥:', error);
                document.getElementById('loading').textContent =
                    'åŠ è½½å¤±è´¥: ' + error.message;
            }
        }

        function applySemanticColors() {
            if (!geometry || !geometry.attributes.color) return;

            const colors = geometry.attributes.color.array;
            const positions = geometry.attributes.position.array;
            const numPoints = positions.length / 3;

            // æ ¹æ®è¯­ä¹‰æ ‡ç­¾åˆ†é…é¢œè‰²
            for (let i = 0; i < numPoints; i++) {
                const idx = i * 3;

                // å‡è®¾è¯­ä¹‰æ ‡ç­¾å­˜å‚¨åœ¨æŸä¸ªå±æ€§ä¸­
                // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªç®€å•çš„é¢œè‰²æ˜ å°„ç¤ºä¾‹
                const x = positions[idx];
                const y = positions[idx + 1];
                const z = positions[idx + 2];

                // æ ¹æ®ç©ºé—´ä½ç½®æ¨¡æ‹Ÿè¯­ä¹‰ï¼ˆå®é™…åº”ä»PLYè¯»å–ï¼‰
                const semClass = getSemanticClass(x, y, z);
                const color = semanticColorToRGB(semClass);

                colors[idx] = color[0] / 255;
                colors[idx + 1] = color[1] / 255;
                colors[idx + 2] = color[2] / 255;
            }

            geometry.attributes.color.needsUpdate = true;
        }

        function getSemanticClass(x, y, z) {
            // ç®€åŒ–çš„è¯­ä¹‰åˆ†ç±»ï¼ˆåŸºäºé«˜åº¦å’Œæ°´å¹³ä½ç½®ï¼‰
            if (y > 3) return 'sky';
            if (y < 0) return 'ground';
            if (z < -10) return 'building';
            if (Math.abs(x) < 5) return 'vegetation';
            return 'other';
        }

        function semanticColorToRGB(semClass) {
            const colors = {
                'sky': [70, 130, 180],
                'ground': [128, 64, 128],
                'building': [70, 70, 70],
                'vegetation': [107, 142, 35],
                'person': [220, 20, 60],
                'car': [0, 0, 142],
                'other': [128, 128, 128]
            };
            return colors[semClass] || colors['other'];
        }

        function setColorMode(mode) {
            colorMode = mode;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('btn-' + mode).classList.add('active');

            if (!geometry || !geometry.attributes.color) return;

            const colors = geometry.attributes.color.array;

            for (let i = 0; i < colors.length; i++) {
                switch (mode) {
                    case 'rgb':
                        colors[i] = originalColors[i];
                        break;
                    case 'semantic':
                        colors[i] = semanticColors[i];
                        break;
                    case 'both':
                        // æ··åˆæ¨¡å¼ï¼š70%è¯­ä¹‰ + 30% RGB
                        colors[i] = semanticColors[i] * 0.7 + originalColors[i] * 0.3;
                        break;
                }
            }

            geometry.attributes.color.needsUpdate = true;
        }

        function resetCamera() {
            if (geometry && geometry.boundingSphere) {
                const center = geometry.boundingSphere.center;
                const radius = geometry.boundingSphere.radius;

                controls.target.copy(center);
                camera.position.set(
                    center.x + radius * 2,
                    center.y + radius * 1.5,
                    center.z + radius * 2
                );
                controls.update();
            }
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = event.target;
            btn.textContent = 'è‡ªåŠ¨æ—‹è½¬: ' + (autoRotate ? 'å¼€' : 'å…³');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            frameId = requestAnimationFrame(animate);

            if (autoRotate && points) {
                points.rotation.y += 0.002;
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
